#include<iostream>
#include<string>
using namespace std;


int a1 = 100;
int a2 = 200;//全局变量

const int a4 = 20;//不加const之前未全局变量，加了const之后未全局常量


//int * func()//形参也会放在栈区
//{
//	int a6 = 10;
//	return &a6;
//}//不能返回局部变量的地址，这是不合法的

int * func2()
{

	int * p = new int(100);//利用new关键字开辟数据空间
							//格式：new 数据类型（数据初始值），同时使用指针返回该变量地址，以便后续调用
							//指针本质还是局部变量，放在栈上，只是指针所指向的变量放在堆上
	//问题就在于p还是栈区数据，其所存放的地址也应该在函数执行完毕后自动释放（仍是问题）
	delete p;
	return p;
	//delete p;//已经返回了p的值，所以相当于已经对该块内存使用完毕，因此要进行内存空间的释放
			 //对应的，如果在return之前就将该内存空间进行释放，那么应该会出错
}

//关于new
//new的基本语法：
int * func3()
{
	int * testnew1 = new int(20);//new返回该数据类型的指针
	return testnew1;//返回该数据在堆区中的地址
	delete testnew1;
}
//利用nw开辟数组空间
void func4() {
	int * testarr = new int[10];
	for (int i = 0; i < 10; i++)
	{
		testarr[i] = i + 627;//给元素赋值
	}
	for (int i = 0; i < 10; i++)
	{
		cout << testarr[i] << endl;
	}
	delete[] testarr;//数组释放的语法
}
int main()
{
	//1.0  内存区分模型
		//C++程序执行时，将整个内存方向分为4个区域：
			//代码区：存放函数体的二进制代码
			//全局区：存放全局变量、静态变量以及常量
			//栈区：编译器自动分配的函数调用栈
			//堆区：程序员分配和释放
			//分区意义：不同数据存放在不同的区，便于灵活编码
	//1.1 代码区：在程序编译后、执行前就已经分配
				//存放CPU执行的机器命令；
				//代码区共享、只读
	//1.2 全局区：全局变量、静态变量、常量区、字符串常量和其他常量
				//程序执行完毕之后，由操作系统释放
	/*int a = 10;
	int b = 20;
	cout << "局部变量a的地址：" << (int)&a << endl
		<<  "局部变量b的地址：" << (int)&b << endl;
	cout << "全局变量a1的地址："<< (int)&a1 << endl
		<<  "全局变量a2的地址："<< (int)&a2 << endl;//局部变量与全局变量并不在一个区中，全局变量在全局区
	//静态变量定义方法：
	static int a3 = 20;
	cout << "静态变量a3的地址：" << (int)&a3 << endl;//全局变量与静态变量都放在全局区
	//常量：字符串常量和const修饰的常量
	//字符串常量：只要加了双引号就是字符串常量，而不是在声明一个变量用于赋值。string chars = "青木";这样叫字符串变量
	cout << "字符串常量的地址：" << (int)&"青木" << endl;
	//const修饰的常量：
					//const修饰的全局变量；
	cout << "const修饰的全局变量（全局常量）的地址：" << (int)&a4 << endl;
					//const修饰的局部变量（不存在全局区）
	const int b2 = 30;//变量取名规则：C-const；g-global；l-local；
	cout << "const修饰的局部变量（局部常量）的地址：" << (int)&b2 << endl;

	//1.3程序运行后，出现栈区：由编译器自动分配与释放
						//存放函数值与局部变量**：不能返回局部变量的地址
						//形参以及局部变量会放在栈区
	int * p1 = func();//存函数返回值时，函数格式要写对，形参不能少
	int * p = func2();
	cout << *p1 << endl;//第一次编译器会对局部变量做一次保留
	cout << *p1 << endl;
	cout << *p << endl;
	cout << *p << endl;
	*/
	//1.4 堆区：程序员进行分配和释放，若程序执行完毕仍未释放，则由系统自动释放
	//C++中使用new关键字来开辟内存空间
	int test200 = 30;//局部变量
	int * test2000 = &test200;//定义一个指针来指向该局部变量，该指针本身也是一个局部变量（此时test2000中存储的是一个16为的二进制地址）
							 //间接寻址借笔不同可能是因为变量重定义
	int * testnew2 = func2();//函数内部使用new开辟了一个内存空间存储整型数据10
							  //使用对应的数据类型来接收函数返回值
							  //之后对该内存使用delete关键字进行释放，如果是先执行完成func3的内部函数，那么按理说就应该在调用时就没有值可以输出
	int * testnew3 = func3();
	cout << "new案例1：testnew3的数值为：" << *testnew3 << endl;
	//cout << "new案例1：testnew2的数值为：" << *testnew2 << endl;//用来测试不同的delete位置是否会对函数使用产生影响
																//因此可以得出结论delete应该放在该内存空间使用完成之后再对其进行释放
	//delete testnew10;//为什么加上该句代码之后后续所有程序都不能正常执行了？
							//是因为主函数中并未调用new函数，所以delete并无空间可以释放
	//cout << "new案例1：testnew1的数值为：" << *testnew10 << endl;//此时返回的是乱码？
																	//因为指针本身也是一个变量只是它所指向的是一个地址罢了
	//cout << (int)&testnew10<< endl;//此时由输出的是什么？
										//此时输出的是一个定义在main函数中的随机变量的地址，做了强制类型转换之后的结果
	func4();
	//new创建的数组的释放


	system("pause");
	return 0;
}