#include<iostream>
#include<string>
using namespace std;



//5.0 对象初始化和清理
//5.1构造函数和析构函数

//构造函数：主要作用在创建对象时，为对象的成员赋值，编译器自动调用
//语法：类名（）{}
	//1、构造函数没有返回值，也不写void；2、函数名与类名相同；
	//3、构造函数也可以有参数，因此可以发生重载；4、程序在调用对象时会自动调用构造，且只会调用一次

//析构函数：主要作用在对象销毁前，系统自动调用，执行一些清理工作
//语法：~类名（）{}
	//1、析构函数没有返回值，也不写void；2、函数名与类名相同，在名称前加~
	//3、析构函数不能有参数，不可以发生重载；；4、程序在对象销毁前会自动调用析构，且只调用一次

//class person
//{
//public:
//
//	//构造函数写在类中
//	person() 
//	{
//		cout << "person中构造函数的调用！" << endl;
//	}//如果没有人为声明，系统会自动添加：person （）{}空函数，没有任何内容
//	~person()
//	{
//		cout << "person中析构函数的调用！" << endl;
//	}
//};
//void test01() 
//{
//	person P1;//P1此时是一个栈上的数据，函数执行完前会自动调用析构
//}


//5.2 构造函数的分类及调用

	//两种分类方式：
		//按参数分：有参构造和无参构造
		//按类型分：普通构造和拷贝构造
	//三种调用方式：括号法、
//class person02 
//{
//public:
//	person02() //无参构造（默认构造）
//	{
//		cout << "person02中默认构造函数的调用！" << endl;
//	}
//	person02(int a)//有参构造
//	{
//		Age = a;
//		cout << "person02中有参构造函数的调用！" << endl;
//	}//上述都是普通构造函数
//	//拷贝构造函数
//	person02(const person02 &p)//写法固定，将p赋值给自己身上 
//	{
//		Age = p.Age;
//		cout << "person02中拷贝构造函数的调用！" << endl;
//	}
//	~person02()
//	{
//		cout << "person02中析构函数的调用！" << endl;
//	}
//	int Age;
//};
////void test02() 
//{
//	//构造函数调用方法
//	//括号法
//	//person02 P2;//默认调用
//	//person02 p3(10);//有参构造函数
//	//person02 P4(p3);//拷贝构造函数
//
//	/*cout << "P3年龄为：" << p3.Age << endl;
//	cout << "P4年龄为：" << P4.Age << endl;*/
//	//注意事项：调用默认构造函数时，不要加（）
//			//person P1()；  编译器会认为是一个函数的声明，不会认为实在创造对象
//	//显示法
//	//person02 P1;//默认构造
//	//person02 P2 = person02(10);//有参构造
//	//person02 P3 = person02(P2);//拷贝构造
//	//				//person02（10）属于匿名对象，但是另一侧是非匿名对象
//	//				//对于匿名对象，当前行执行完系统会立即回收匿名对象
//	//person02(20);//此时就创建一个匿名对象
//	////注意事项：不要利用拷贝构造函数来初始化一个匿名对象
//	//				//person （P3）；编译器会认为（P3）=P3，属于是重定义，有无（）并没有作用
//	//cout << "aaaa" << endl;
//	//隐式转换法
//	//person02 P4 = 10;//相当于person02 P4 = person02(10);有参构造的调用
//	//person02 P5 = P4;
//}

//5.3构造函数调用时机

//class person03 
//{
//public:
//	person03() 
//	{
//		cout << "person03的默认构造函数的调用！！！" << endl;
//	
//	}
//	person03(int a)
//	{
//		Age = a;
//		cout << "person03中有参构造函数的调用!!!" << endl;
//	}
//	person03(const person03 &PP1) //写法要牢记
//	{
//		Age = PP1.Age;
//		cout << "person03中拷贝构造函数的调用！！！！" << endl;
//	}
//	~person03()
//	{
//		cout << "person中析构函数的调用！！！" << endl;
//	}
//	int Age;
//
//
//};
////情况一：使用一个已经创建完毕的对象来初始化一个新对象
//void test001() 
//{
//	person03 P1;
//	person03 P2(10);
//	person03 P3(P2);//使用P2来初始化P3
//
//	cout << "P3的年龄为:" <<P3.Age<< endl;
//}
////情况二：值传递的方式的给函数参数传值
//void dowork(person03 P) { P.Age = 1000; }
//void test002() 
//{
//	person03 P4;
//	P4.Age = 10;
//	dowork(P4);//调用dowork时进行的是值传递
//	cout << "P4的年龄为：" << P4.Age << endl;
//}
////情况三：以值方式来返回局部对象
//person03 dowork2() 
//{
//	person03 P5;
//	return P5;
//}
//void test003() { person03 P6 = dowork2(); }

//5.4 构造函数的调用规则

//Tips：默认情况下，C++只要创建了一个类，就会为其调用三个函数：默认构造函数、默认析构函数、默认拷贝构造函数
//class person04 
//{
//public:
//	person04() 
//	{
//		cout << "person04的默认构造函数！！！" << endl;
//	}
//	//person04(int a)
//	//{
//	//	Age = a;
//	//	cout << "person04的有参构造函数！！！" << endl;
//	//}
//	//person04(const person04 &p)
//	//{
//	//	Age = p.Age;
//	//	cout << "person04的拷贝构造函数！！！" << endl;
//	//}
//	~person04()
//	{
//		cout << "person04的析构函数！！！" << endl;
//	}
//	int Age;
//};
////规则一：只要有有参构造函数就不会再有默认构造函数，但仍会有拷贝构造函数
//void test10() 
//{
//	//person04 P;//只要我们人为定义了有参构造函数，系统就不会再自动提供默认构造函数，因此这句语句就会报错
//};
////规则二：只要有拷贝构造函数，系统就不会在提供其余两种构造函数
//void test20() 
//{
//	//person04 P(10);//只要人为定义了拷贝构造函数，系统就不会在自动提供其余两种构造函数，因此语句报错
//};
////验证Tips
//void test30() 
//{
//	person04 P;
//	P.Age = 10;
//	cout << "P.Age=" << P.Age<<endl;
//	person04 P2(P);//此时是没有人为定义拷贝构造函数的
//	cout << "P2.Age=" << P2.Age << endl;
//};

//5.5 深拷贝与浅拷贝

//浅拷贝：简单的赋值拷贝操作；深拷贝：在堆区重新申请一个空间，进行拷贝操作
//Tips：如果有属性在堆区开辟了内存空间，则必须人为定义拷贝构造函数，防止浅拷贝带来的问题
//class person200{
//public:
//	person200();
//	person200(int a,int  Height);
//	person200(const person200 &P);
//	~person200();
//	int Age;
//	int * Height001;
//private:
//
//};
//
//person200::person200()
//{
//	cout << "person200中默认构造函数的调用" << endl;
//}
//person200::person200(int a,int  Height) 
//{
//	Height001 = new int(Height);//new返回值是一个地址，所以要用指针类型的变量来接收
//								//此时是将形参中的值传递给了类中的成员变量
//	Age = a;
//	cout << "person200中有参构造函数的调用！！！" << endl;
//}
//person200::person200(const person200 &P) 
//{
//	Age == P.Age;//Age是栈区变量，因此采用浅拷贝不会有所影响
//	//对于Height，就不能在采用浅拷贝来进行操作，必须要进行深拷贝（重新定义一块内存用于接收传进来的地址）
//	Height001 = new int(*P.Height001);//使用new关键字，重新在堆区开辟一块内存用于存放接收的数据
//										//这就是浅拷贝转换为深拷贝的方法，必须要这么写
//								//new关键字：new 数据类型（初始值）=在堆区开辟了一块内存，存放的是“数据类型”的数据，初值是“初值”
//
//};
//person200::~person200()
//{
//	delete Height001;//注意new和delete的用法
//	Height001 = NULL;
//	cout << "person200中析构函数的调用！！！" << endl;
//}
//
//void test300() 
//{
//	person200 P;
//	P.Age = 10;
//	person200 P2(10, 175);//采用有参构造函数来构造一个对象
//	cout << "P2.Age=" << P2.Age << "P2.Height=" << *P2.Height001 << endl;
//	person200 P3(P2);//采用拷贝构造函数来构造一个对象
//							//程序执行后就由于浅拷贝出现了一个问题，导致了对于堆区存储的重复释放
//									//要避免浅拷贝导致的问题就需要将浅拷贝改为深拷贝――手动定义拷贝构造函数
//	cout << "P3.Age=" << P3.Age << "P3.Height=" << *P3.Height001 << endl;
//	//此时，生成变量之后，P、P2、P3中的Height是一个定义在堆区的变量，需要程序员手动释放，
//			//此时就体现了析构函数的作用――当出现堆区变量是，可以在析构函数中对其进行释放操作
//};

//5.6 初始化列表（初始化属性）

////语法：构造函数（）：属性1（值1），属性2（值2），属性3（值3）{}
//
//class person627
//{
//public:
//	//构造函数
//	person627() 
//	{
//		cout << "person627中默认构造函数的调用！！！" << endl;
//	};
//	person627(int a) :P_a(a)//初始化列表传值的方法
//								//此处既可以将初值设为待传变量的值，也可以自己设置一个值：P_a（10）也可以
//	{
//		//a = a;//传统的有参构造函数的传值方法
//		cout << "person627中有参构造函数的调用！！！" << endl;
//	};
//	person627(const person627 &P) 
//	{
//		cout << "person627中拷贝构造函数的调用！！" << endl;
//	};
//	~person627()
//	{
//		cout << "person627中析构函数的调用" << endl;
//	}
//	int P_a;
//};
//
//void test627() 
//{
//	person627 P;
//	P.P_a = 6;
//	cout << "P.P_a=" << P.P_a << endl;
//	person627 P1(7);
//	cout << "P1.P_a=" << P1.P_a << endl;
//	person627 P2(P1);
//	cout << "P2.P_a=" << P2.P_a << endl;
//};
////注意初始化列表的语法就可

//5.7 类对象作为类成员

//
//	//C++类中的成员可以是另一个类的对象，我们称该成员为对象成员
////当其他类作为本类的成员时，构造时先构造类对象，在构造自身；析构时先析构自身，再析构类成员
//class A
//{
//public:
//	A() 
//	{
//		cout << "A中默认构造函数的调用！！！" << endl;
//	};
//	A(int a):aa(a)//注意初始化列表的写法（：不能少）
//	{
//		cout << "A中有参构造函数的调用" << endl;
//	};
//	~A()
//	{
//		cout << "A中析构函数的调用！！！" << endl;
//	};
//	int aa;
//};
//class B 
//{
//public:
//	B()
//	{
//		cout << "B中默认构造函数的调用" << endl;
//	};
//	B(int a1,int a2,int a3,int a4):bbb1(a1),bbb2(a2),bbb3(a3),a(a4)
//														//此处给a传值相当于编译器自动添加了：a.aa=a4；
//															//这是构造函数调用方式中的隐式转换法
//	{
//		cout << "B中有参构造函数的调用" << endl;
//	};
//	~B()
//	{
//		cout << "B中析构函数的调用！！！" << endl;
//	}
//	int bbb1;
//	int bbb2;
//	int bbb3;
//	A a;
//};//若要验证创建B对象时，A与B的构造和析构顺序，只需在相应的构造和析构函数中添加标识语句即可
//
//void test666() 
//{
//	B b1(1,2,3,4);
//	cout << "对象b1中的信息为："<<b1.a.aa << " "//此时b1中的成员a是一个对象，不能通过cout直接输出，cout只能输出具体的数据
//		<< b1.bbb1 << " "
//		<< b1.bbb3 << " "
//		<< b1.bbb2 << "\n ";
//};

//5.8 静态成员（static关键字）

////静态成员是在成元变量与成员函数前加上关键字 static，称之为静态成员
////静态成员变量：
//		//所有对象共享一份数据；
//		//在编译阶段分配内存；
//		//类内声明，类外初始化。
////静态成员函数：
//		//所有对象共享同一个函数
//		//静态成员函数只能访问静态成员变量
//
//class L1 
//{
//public:
//	//静态成员函数
//	static void  func111() 
//	{
//		AAA = 100;//静态成员函数可以访问静态成员变量
//		//BBB = 200;//静态成员函数不能访问静态成员变量，无法区分该属性属于哪个对象
//								//静态成员变量谁都不属于，同理，静态成员函数也没有归属
//								//因此调用一个没有归属的函数去改变一个有归属的属性时，函数不知道改变的是谁的属性
//		cout << "PPP中的静态成员函数！！！" << endl;
//	}
//	static int AAA;
//	int BBB;
//private:
//	static void func2() 
//	{
//		cout << "私有权限的静态成员函数的调用！！！" << endl;
//	}
//};
//int L1::AAA = 0;//静态成员变量在类内声明，类外初始化
//					//还需要声明该变量的作用域（PPP：：）
//
////静态成员函数的两种访问方式：
//void testL1() 
//{
//	//1、通过对象进行访问
//	L1 l1;
//	l1.func111();
//	//2、通过类名进行访问（不属于某一个对象，因此可以通过类名直接访问）
//	L1::func111();
//};//问题所在，并不知道如何解决
//		//函数中的权限声明不能省略，默认的都是private，因此会导致不能访问
//				//遇见问题很多都可能是自己写的有问题，要仔细检查
////静态成员函数也有访问权限，如果是在私有作用域下，那么是不能在类外进行访问的




int main() 
{
	////test01();//函数调用（）不能少
	////person P2;//此时就只有在整个main函数执行完毕之前才会调用析构，就不是我们可以看见的了
	////test02();
	////test300();//调用函数
	////test001();
	////test002();
	////test003();
	////test30();//调用程序，验证Tips
	//		 //此时拷贝构造函数仍可正常使用，表明系统自动生成了拷贝构造函数
	////test627();
	//test666();

	testL1();
	cout << endl;
	system("pause");
	return 0;
}